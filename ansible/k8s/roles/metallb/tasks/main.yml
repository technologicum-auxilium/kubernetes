---
# roles/metallb/tasks/main.yml
#
# Requisitos externos (no seu projeto):
# - templates/metallb-values.yaml.j2
# - templates/ipaddresspool.yaml.j2
# - templates/l2advertisement.yaml.j2
#
# Variáveis esperadas (padrões em defaults/vars):
# - metallb_kubeconfig: /etc/kubernetes/admin.conf
# - metallb_namespace: metallb-system
# - metallb_release_name: metallb
# - metallb_helm_repo_name: metallb
# - metallb_helm_repo_url: https://metallb.github.io/metallb
# - metallb_chart_version: "" (vazio = latest)
# - metallb_master_group: "master" (ou "controlplane")
# - metallb_control_host: "" (host específico opcional)
# - metallb_address_pools: lista de dicts {name, addresses: [...]}
# - metallb_l2advertisements: lista de dicts {name, ipAddressPools: [...]}

# === 0) Resolver o host de controle (UMA VEZ) ================================
# Preferência:
#   1) metallb_control_host (se definido e não vazio)
#   2) primeiro do grupo metallb_master_group
#   3) primeiro do grupo 'controlplane'
#   4) primeiro do grupo 'master'
#   5) primeiro host do play
#   6) inventory_hostname (fallback)

- name: Build control-host candidate list (run once)
  ansible.builtin.set_fact:
    metallb_cp_candidates: >-
      {{
        (
          ([] if (metallb_control_host | default('') | length == 0) else [metallb_control_host])
          + (groups[metallb_master_group] | default([]))
          + (groups['controlplane']       | default([]))
          + (groups['master']             | default([]))
          + (ansible_play_hosts_all       | default([]))
        )
      }}
  run_once: true

- name: Pick control host from candidates (run once)
  ansible.builtin.set_fact:
    metallb_cp_host: "{{ (metallb_cp_candidates | select() | list | first) | default(inventory_hostname) }}"
    cacheable: true
  run_once: true

# Helper: para delegar sempre ao mesmo host de controle:
#   delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 1) Garantir Helm/dep no host de controle =================================
# Se você tiver um tasks/prereqs_helm.yml, importe-o; senão, garanta helm aqui.
- name: Ensure Helm binary is present (quick check)
  ansible.builtin.command: helm version --short
  changed_when: false
  failed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# jq é usado no patch do ValidatingWebhookConfiguration
- name: Ensure jq present on control host
  ansible.builtin.apt:
    name: jq
    state: present
    update_cache: yes
  become: true
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 2) Helm repo + namespace + values =======================================
- name: Add MetalLB Helm repo
  kubernetes.core.helm_repository:
    name: "{{ metallb_helm_repo_name }}"
    repo_url: "{{ metallb_helm_repo_url }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Helm repo update
  ansible.builtin.command: helm repo update
  changed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Ensure namespace exists
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    get ns {{ metallb_namespace }}
  register: _ns_check
  changed_when: false
  failed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Create namespace if missing
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    create ns {{ metallb_namespace }}
  when: _ns_check.rc != 0
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Template MetalLB values
  ansible.builtin.template:
    src: metallb-values.yaml.j2
    dest: /tmp/metallb-values.yaml
    mode: "0644"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 3) Instalar/atualizar o chart ===========================================
- name: Install/Upgrade MetalLB via Helm
  kubernetes.core.helm:
    name: "{{ metallb_release_name }}"
    chart_ref: "{{ metallb_helm_repo_name }}/metallb"
    chart_version: "{{ (metallb_chart_version | trim) if (metallb_chart_version | trim | length > 0) else omit }}"
    release_namespace: "{{ metallb_namespace }}"
    create_namespace: true
    values_files:
      - /tmp/metallb-values.yaml
    kubeconfig: "{{ metallb_kubeconfig }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 3.1) Esperar controller disponível ======================================
- name: Wait for metallb-controller Available
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    -n {{ metallb_namespace }}
    wait deploy/metallb-controller --for=condition=Available=True --timeout=180s
  changed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 3.2) Esperar endpoints do webhook (até 2min; não falhar) ================
- name: Wait for webhook service endpoints
  ansible.builtin.shell: |
    kubectl --kubeconfig={{ metallb_kubeconfig }} -n {{ metallb_namespace }} \
      get endpoints metallb-webhook-service -o jsonpath='{.subsets[*].addresses[*].ip}'
  register: _webhook_eps
  retries: 24
  delay: 5
  until: _webhook_eps.stdout | trim | length > 0
  changed_when: false
  failed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 4) IPAddressPool (render + validar) =====================================
- name: Render IPAddressPool manifests (robusto)
  ansible.builtin.copy:
    dest: "/tmp/metallb-ipool-{{ item.name }}.yaml"
    mode: "0644"
    content: "{{ lookup('template', 'ipaddresspool.yaml.j2', template_vars={'item': item}) }}"
  loop: "{{ metallb_address_pools }}"
  loop_control:
    label: "{{ item.name }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Stat IPAddressPool manifests
  ansible.builtin.stat:
    path: "/tmp/metallb-ipool-{{ item.name }}.yaml"
  register: _ipool_stat
  loop: "{{ metallb_address_pools }}"
  loop_control:
    label: "{{ item.name }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Assert IPAddressPool manifests are non-empty
  ansible.builtin.assert:
    that:
      - item.stat.exists
      - (item.stat.size | int) > 0
    fail_msg: "Rendered {{ item.stat.path }} is empty"
    success_msg: "OK: {{ item.stat.path }} has content"
  loop: "{{ _ipool_stat.results }}"
  loop_control:
    label: "{{ item.stat.path | default('unknown') }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 4.x) Aplicar IPAddressPool (com fallback de webhook) =====================
- name: Apply IPAddressPool manifests (normal attempt)
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    apply -f /tmp/metallb-ipool-{{ item.name }}.yaml
  loop: "{{ metallb_address_pools }}"
  loop_control:
    label: "{{ item.name }}"
  register: _apply_ipool_normal
  changed_when: >
    ('created' in (_apply_ipool_normal.stdout | default(''))) or
    ('configured' in (_apply_ipool_normal.stdout | default('')))
  failed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Flag webhook refused for IPPool
  ansible.builtin.set_fact:
    _need_webhook_patch_ipool: >-
      {{
        (_apply_ipool_normal.stderr | default('')) is search('connect: connection refused')
      }}
  run_once: true

- name: Patch VWC to failurePolicy=Ignore (TEMP) for IPPool
  ansible.builtin.shell: |
    set -e
    VWC=$(kubectl --kubeconfig={{ metallb_kubeconfig }} get validatingwebhookconfigurations -o name | grep metallb || true)
    if [ -n "$VWC" ]; then
      kubectl --kubeconfig={{ metallb_kubeconfig }} get $VWC -o json \
      | jq '.webhooks |= map(.failurePolicy="Ignore")' \
      | kubectl --kubeconfig={{ metallb_kubeconfig }} apply -f -
    fi
  when: _need_webhook_patch_ipool | default(false)
  changed_when: true
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Re-apply IPAddressPool under Ignore
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    apply -f /tmp/metallb-ipool-{{ item.name }}.yaml
  loop: "{{ metallb_address_pools }}"
  loop_control:
    label: "{{ item.name }}"
  when: _need_webhook_patch_ipool | default(false)
  register: _apply_ipool_ignore
  changed_when: >
    ('created' in (_apply_ipool_ignore.stdout | default(''))) or
    ('configured' in (_apply_ipool_ignore.stdout | default('')))
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 5) L2Advertisement (render + validar) ===================================
- name: Render L2Advertisement manifests (robusto)
  ansible.builtin.copy:
    dest: "/tmp/metallb-l2adv-{{ item.name }}.yaml"
    mode: "0644"
    content: "{{ lookup('template', 'l2advertisement.yaml.j2', template_vars={'item': item}) }}"
  loop: "{{ metallb_l2advertisements }}"
  loop_control:
    label: "{{ item.name }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Stat L2Advertisement manifests
  ansible.builtin.stat:
    path: "/tmp/metallb-l2adv-{{ item.name }}.yaml"
  register: _l2_stat
  loop: "{{ metallb_l2advertisements }}"
  loop_control:
    label: "{{ item.name }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Assert L2Advertisement manifests are non-empty
  ansible.builtin.assert:
    that:
      - item.stat.exists
      - (item.stat.size | int) > 0
    fail_msg: "Rendered {{ item.stat.path }} is empty"
    success_msg: "OK: {{ item.stat.path }} has content"
  loop: "{{ _l2_stat.results }}"
  loop_control:
    label: "{{ item.stat.path | default('unknown') }}"
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 5.x) Aplicar L2Advertisement (com mesmo fallback) =======================
- name: Apply L2Advertisement manifests (normal attempt)
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    apply -f /tmp/metallb-l2adv-{{ item.name }}.yaml
  loop: "{{ metallb_l2advertisements }}"
  loop_control:
    label: "{{ item.name }}"
  register: _apply_l2_normal
  changed_when: >
    ('created' in (_apply_l2_normal.stdout | default(''))) or
    ('configured' in (_apply_l2_normal.stdout | default('')))
  failed_when: false
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

- name: Flag webhook refused for L2Adv
  ansible.builtin.set_fact:
    _need_webhook_patch_l2: >-
      {{
        (_apply_l2_normal.stderr | default('')) is search('connect: connection refused')
      }}
  run_once: true

- name: Re-apply L2Advertisement under Ignore (if needed)
  ansible.builtin.command: >
    kubectl --kubeconfig={{ metallb_kubeconfig }}
    apply -f /tmp/metallb-l2adv-{{ item.name }}.yaml
  loop: "{{ metallb_l2advertisements }}"
  loop_control:
    label: "{{ item.name }}"
  when: _need_webhook_patch_ipool | default(false) or _need_webhook_patch_l2 | default(false)
  register: _apply_l2_ignore
  changed_when: >
    ('created' in (_apply_l2_ignore.stdout | default(''))) or
    ('configured' in (_apply_l2_ignore.stdout | default('')))
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"

# === 6) Reverter o VWC para Fail (se aplicamos Ignore) =======================
- name: Revert VWC failurePolicy back to Fail
  ansible.builtin.shell: |
    set -e
    VWC=$(kubectl --kubeconfig={{ metallb_kubeconfig }} get validatingwebhookconfigurations -o name | grep metallb || true)
    if [ -n "$VWC" ]; then
      kubectl --kubeconfig={{ metallb_kubeconfig }} get $VWC -o json \
      | jq '.webhooks |= map(.failurePolicy="Fail")' \
      | kubectl --kubeconfig={{ metallb_kubeconfig }} apply -f -
    fi
  when: _need_webhook_patch_ipool | default(false) or _need_webhook_patch_l2 | default(false)
  changed_when: true
  run_once: true
  delegate_to: "{{ hostvars[ansible_play_hosts_all[0]].metallb_cp_host }}"
